# goit-algo-hw-10

## Проєкт
Цей проєкт містить реалізацію двох алгоритмічних задач:
1. Алгоритми розміну суми монетами
2. Обчислення інтеграла методом Монте-Карло

## Структура проєкту
```
goit-algo-hw-10/
├── coin_change.py          # Алгоритми розміну суми
├── coin_change_output.txt  # Результати роботи алгоритмів
├── monte_carlo_integral.py # Обчислення інтеграла
├── monte_carlo_output.txt  # Результати обчислень
├── requirements.txt        # Залежності проєкту
└── README.md              # Документація
```

## Завдання 1: Розмін суми монетами

### Реалізовані функції
- `find_coins_greedy(amount, coins)` - жадібний алгоритм, який на кожному кроці вибирає найбільший доступний номінал
- `find_min_coins(amount, coins)` - алгоритм динамічного програмування для знаходження мінімальної кількості монет

Обидві функції повертають результат у вигляді словника `{номінал: кількість}`. За замовчуванням використовується стандартний набір монет `[50, 25, 10, 5, 2, 1]`.

### Запуск програми
```bash
python coin_change.py
```
Програма виконує автоматичну перевірку коректності роботи алгоритмів та проводить порівняльний аналіз їх продуктивності.

### Аналіз алгоритмів

**Жадібний алгоритм:**
- Часова складність: `O(m)`, де `m` - кількість номіналів монет
- Просторова складність: `O(1)`
- Для кожного номіналу виконується одна операція ділення
- Алгоритм завжди вибирає найбільший можливий номінал на кожному кроці

**Динамічне програмування:**
- Часова складність: `O(amount × m)`
- Просторова складність: `O(amount)`
- Побудова таблиці мінімальної кількості монет для всіх значень від 0 до вказаної суми
- Гарантує знаходження оптимального розв'язку для будь-якого набору монет

### Властивості алгоритмів

Для стандартних систем монет (таких як `[50, 25, 10, 5, 2, 1]`) жадібний алгоритм завжди знаходить оптимальне рішення, що співпадає з результатом динамічного програмування. Однак для довільних наборів монет жадібний підхід не завжди гарантує мінімальну кількість монет.

### Порівняння продуктивності

На основі тестування з 5000 випадковими сумами в діапазоні `[1, 5000]` з використанням монет `[50, 25, 10, 5, 2, 1]`:

- **Жадібний алгоритм** працює значно швидше (константний час для кожного запиту)
- **Алгоритм динамічного програмування** приблизно на порядок повільніший і вимагає більше пам'яті
- Обидва алгоритми дають однакові результати для канонічної системи монет

### Рекомендації щодо вибору алгоритму

- Для **великих сум зі стандартним набором монет** - використовуйте **жадібний алгоритм** (швидший, економніший за пам'яттю)
- Для **довільних наборів монет** або коли потрібна гарантовано мінімальна кількість монет - застосовуйте **динамічне програмування** (повільніший, але оптимальний для будь-якого набору)
- Жадібний алгоритм є оптимальним лише для канонічних систем монет, де кожен номінал більший за наступний принаймні вдвічі

## Завдання 2: Обчислення інтеграла методом Монте-Карло

### Опис методу
Файл `monte_carlo_integral.py` реалізує обчислення визначеного інтеграла методом Монте-Карло з використанням схеми усереднення значень:
∫ₐᵇ f(x) dx ≈ (b - a) × (1/n) × Σ f(xᵢ), де xᵢ ~ U(a,b)


### Приклад використання
У прикладі використовується функція `f(x) = x²` на інтервалі `[0, 2]`. Аналітичне значення цього інтеграла:
∫₀² x² dx = (2³ - 0³)/3 = 8/3 ≈ 2.6666666667


### Запуск програми
```bash
python monte_carlo_integral.py --a 0 --b 2 --n 100000 --seed 42
```
### Функціональність програми

Програма `monte_carlo_integral.py` надає наступний функціонал:

- **Обчислення інтеграла** методом Монте-Карло з використанням випадкових точок
- **Порівняльний аналіз** результатів з трьома методами:
  - Метод Монте-Карло
  - Функція `quad` з бібліотеки SciPy (детермінований метод)
  - Аналітичний розв'язок
- **Візуалізація процесу** обчислення через генерацію графіка
- **Статистичний аналіз** точності методу
- **Гнучкі параметри** для налаштування обчислень:
  - Межі інтегрування (`a` та `b`)
  - Кількість випадкових точок (`n`)
  - Seed для відтворюваності результатів

### Ключові параметри запуску

```bash
--a 0          # Нижня межа інтегрування
--b 2          # Верхня межа інтегрування  
--n 100000     # Кількість випадкових точок
--seed 42      # Seed для генератора випадкових чисел
```

### Перевірка точності методу

- **Статистична збіжність**: Результати методу Монте-Карло узгоджуються з аналітичним розрахунком та результатами `quad` в межах статистичної похибки
- **Швидкість збіжності**: Статистична похибка зменшується пропорційно `O(1/√n)`
- **Вплив кількості точок**: Збільшення параметра `n` покращує точність, але збільшує час обчислення
- **Відтворюваність**: Використання seed забезпечує однакові результати при повторних запусках

### Висновки щодо методу Монте-Карло

**Переваги:**
- Коректно оцінює значення інтеграла
- Ефективний для багатовимірних задач
- Працює з функціями складної форми
- Простий у реалізації

**Обмеження:**
- Для одновимірних інтегралів від простих функцій детерміновані методи точніші та швидші
- Вимагає великої кількості точок для високої точності
- Результат залежить від генератора випадкових чисел

**Застосування:** Метод особливо корисний для задач, де традиційні детерміновані методи стають неефективними або надто повільними.


### Необхідні бібліотеки
```
numpy
scipy
matplotlib
```

### Версії Python
- Рекомендується Python 3.8 або вище
- Всі скрипти протестовані на Python 3.8+

### Встановлення залежностей
```bash
pip install -r requirements.txt
```
## Тестування та валідація

### Самоперевірка алгоритмів

**Для завдання 1 (розмін монет):**
- Перевірка коректності обох алгоритмів на контрольних значеннях
- Порівняння результатів greedy та DP підходів
- Валідація суми розміну (повинна дорівнювати початковій сумі)
- Тестування на крайних випадках (сума = 0, сума = 1)

**Для завдання 2 (інтеграл Монте-Карло):**
- Порівняння з аналітичним розв'язком
- Перевірка збіжності при збільшенні кількості точок
- Валідація з використанням SciPy quad
- Статистичний аналіз похибки

### Формат виводу результатів

**Текстові файли:**
- `coin_change_output.txt` - результати роботи алгоритмів розміну
- `monte_carlo_output.txt` - результати обчислення інтегралів

**Графічні виходи:**
- `mc_plot.png` - візуалізація методу Монте-Карло

**Консольний вивід:**
- Детальна інформація про процес обчислень
- Час виконання алгоритмів
- Порівняльна статистика




